//! # Overview
//! 
//! wye_impl provides the proc-macros [wye] and [wyre] used by [wye](https://github.com/mstone/wye).
//! 
//! # Guide-level explanation
//! 
//! [wye] transforms the functions it is used to annotate to record dataflow 
//! from arguments to returned results.
//! 
//! [wyre] transforms the expressions -- typically call-sites -- that it spans
//! to record data-flow from variables to arguments of the functions being called.
//! 
//! # Reference-level explanation
//! 
//! ## Architecture
//! 
//! [wye] and [wyre] work by using [syn], [quote], and [proc_macro2] to 
//! parse, analyze, and transform their inputs, and [trybuild] for testing.
//! 
//! The main axis of the analysis is: statement-level expressions can be 
//! transformed into equivalent sequences of bindings of fresh variables 
//! to sub-terms and of applications of the constructor of the top-level 
//! term to these fresh variables.
//! 
//! Then, in between definition and use, these fresh variables and their 
//! corresponding dataflows to the result of the expression being 
//! transformed can be logged.
//! 
//! ## Key Items
//! 
//! * [wye::get_wye] provides access to a [&mut wye::Logger], which provides
//!   APIs for dataflow recording and shadow call-stack frame management for
//!   use in the code generated by the [wye] and [wyre] macros.
//! 
//! * [WyeArgs] and [WyeArgMap] are used by [wye] to support custom formatting.
//! 
//! * [process_stmts] is the root of the common logic shared by [wye] and [wyre].
//! 
//! ## Method
//! 
//! I need a way to take an expression, 
//! 
//! 1. I need to enumerate bound variables in the expression and to look up dataflow coordinates for their values.
//! 2. I need to generate and bind fresh variables for sub-expressions, and to record dataflow from the bound variables they contain to them.
//! 3. I need to generate and bind a fresh variable for the result of the expression, to record the result in the dataflow at suitable coordinates, and to record the dataflow from the sub-expressions to the result.
//! 4. I need to smuggle all these coordinates back and forth across stack frames at the appropriate moments.
//! 5. I need to coalesce or to simplify how I print the dataflow graph to minimize unhelpful duplication of detail.
//! 
//! # See Also
//! 
//! * [wye](https://github.com/mstone/wye)

use std::{hash::{Hash, Hasher}, collections::{hash_map::DefaultHasher, HashMap}};

use proc_macro2::TokenStream;
use quote::{ToTokens, format_ident, TokenStreamExt};
use syn::{parse_macro_input, parse_quote, Item, Expr, punctuated::Punctuated, token::{Comma}, Block, Stmt, parse2, spanned::Spanned, Ident, FieldValue, ItemFn, parenthesized, Signature,};

fn process_item(args: &WyeArgMap, item: &mut Item) {
    if let Item::Fn(item_fn) = item {
        let ItemFn{sig, block, ..} = item_fn;
        let Block{stmts, ..} = &mut **block;
        process_stmts(args, Some(sig), stmts);
    }
}

/// Given custom formatting arguments `args` and an optional function signature `sig`, 
/// rewrite the given statements `stmts` to simultaneously record dataflow.
fn process_stmts(args: &WyeArgMap, sig: Option<&Signature>, stmts: &mut Vec<Stmt>) {
    
}

fn hash<T: Hash>(t: T) -> u64 {
    let mut h = DefaultHasher::new();
    t.hash(&mut h);
    h.finish()
}

#[derive(Debug)]
struct FormatArgs(Punctuated<Expr, Comma>);

impl syn::parse::Parse for FormatArgs {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut format_args: Punctuated<Expr, Comma> = Punctuated::new();
        loop {
            format_args.push_value(input.parse()?);
            if input.is_empty() {
                break;
            }
            format_args.push_punct(input.parse()?);
        }
        Ok(FormatArgs(format_args))
    }
}

impl quote::ToTokens for FormatArgs {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        tokens.append_separated(&self.0, Comma::default());
    }
}

struct Stmts(Vec<Stmt>);

impl syn::parse::Parse for Stmts {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        Block::parse_within(input).map(Stmts)
    }
}

impl quote::ToTokens for Stmts {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let brace_token = syn::token::Brace::default();
        brace_token.surround(tokens, |tokens| {
            tokens.append_all(&self.0);
        });
    }
}

struct WyeArg{
    ident: syn::Ident,
    colon_token: syn::Token![:],
    expr: syn::Expr,
}

impl syn::parse::Parse for WyeArg {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        Ok(Self{
            ident: input.parse()?,
            colon_token: input.parse()?,
            expr: input.parse()?,
        })
    }
}

impl quote::ToTokens for WyeArg {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        self.ident.to_tokens(tokens);
        self.colon_token.to_tokens(tokens);
        self.expr.to_tokens(tokens);
    }
}

struct WyeArgs(Punctuated<WyeArg, Comma>);

impl syn::parse::Parse for WyeArgs {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut args = Punctuated::new();
        loop {
            if input.is_empty() {
                break;
            }
            args.push(input.parse()?);
            if input.is_empty() {
                break;
            }
            let comma: Comma = input.parse()?;
            args.push_punct(comma);
        }
        Ok(Self(args))
    }
}

impl quote::ToTokens for WyeArgs {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        tokens.append_separated(self.0.iter(), Comma::default())
    }
}

type WyeArgMap = HashMap<Ident, Expr>;

impl WyeArgs {
    fn process(&self) -> WyeArgMap {
        let mut args = HashMap::new();
        for arg in self.0.iter() {
            args.insert(arg.ident.clone(), arg.expr.clone());
        }
        args
    }
}

struct WyreExpr {
    args: Option<(syn::token::Paren, WyeArgs)>,
    stmts: Stmts,
}

impl syn::parse::Parse for WyreExpr {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        if input.peek(syn::token::Paren) {
            let content;
            Ok(Self {
                args: Some((parenthesized!(content in input), content.parse()?)),
                stmts: input.parse()?,
            })
        } else {
            Ok(Self {
                args: None,
                stmts: input.parse()?
            })
        }
    }
}

impl quote::ToTokens for WyreExpr {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        // Note: self.args intentionally does *not* get re-printed
        // since it would not be valid syntax.
        // if let Some((paren_token, args)) = self.args {
        //     paren_token.surround(tokens, |tokens| {
        //         args.to_tokens(tokens);
        //     })
        // }
        self.stmts.to_tokens(tokens);
    }
}

#[proc_macro_attribute]
pub fn wye(args: proc_macro::TokenStream, input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let args = if !args.is_empty() {
        parse_macro_input!(args as WyeArgs).process()
    } else {
        WyeArgMap::new()
    };
    let mut input = parse_macro_input!(input as Item);
    process_item(&args, &mut input);
    let tokens = input.into_token_stream();
    tokens.into()
}

#[proc_macro]
pub fn wyre(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let mut input = parse_macro_input!(input as WyreExpr);
    let args = input.args.as_ref().map(|args| args.1.process()).unwrap_or_else(WyeArgMap::new);
    process_stmts(&args, None::<&Signature>, &mut input.stmts.0);
    let tokens = input.into_token_stream();
    tokens.into()
}