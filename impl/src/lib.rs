//! # Overview
//! 
//! wye_impl provides the proc-macros [wye] and [wyre] used by [wye](https://github.com/mstone/wye).
//! 
//! # Guide-level explanation
//! 
//! [wye] transforms the functions it is used to annotate to record dataflow 
//! from arguments to returned results.
//! 
//! [wyre] transforms the expressions -- typically call-sites -- that it spans
//! to record data-flow from variables to arguments of the functions being called.
//! 
//! # Reference-level explanation
//! 
//! ## Architecture
//! 
//! [wye] and [wyre] work by using [syn], [quote], and [proc_macro2] to 
//! parse, analyze, and transform their inputs, and [trybuild] for testing.
//! 
//! The main axis of the analysis is: statement-level expressions can be 
//! transformed into equivalent sequences of bindings of fresh variables 
//! to sub-terms and of applications of the constructor of the top-level 
//! term to these fresh variables.
//! 
//! Then, in between definition and use, these fresh variables and their 
//! corresponding dataflows to the result of the expression being 
//! transformed can be logged.
//! 
//! ## Key Items
//! 
//! * [wye::get_wye] provides access to a [&mut wye::Logger], which provides
//!   APIs for dataflow recording and shadow call-stack frame management for
//!   use in the code generated by the [wye] and [wyre] macros.
//! 
//! * [WyeArgs] and [WyeArgMap] are used by [wye] to support custom formatting.
//! 
//! * [process_stmts] is the root of the common logic shared by [wye] and [wyre].
//! 
//! ## Method
//! 
//! I need a way to take an expression, 
//! 
//! 1. I need to enumerate bound variables in the expression and to look up dataflow coordinates for their values.
//! 2. I need to generate and bind fresh variables for sub-expressions, and to record dataflow from the bound variables they contain to them.
//! 3. I need to generate and bind a fresh variable for the result of the expression, to record the result in the dataflow at suitable coordinates, and to record the dataflow from the sub-expressions to the result.
//! 4. I need to smuggle all these coordinates back and forth across stack frames at the appropriate moments.
//! 5. I need to coalesce or to simplify how I print the dataflow graph to minimize unhelpful duplication of detail.
//! 
//! # See Also
//! 
//! * [wye](https://github.com/mstone/wye)
#![feature(proc_macro_span)]
use std::{collections::{HashMap, HashSet, hash_map::DefaultHasher}, fmt::Display, hash::{Hash, Hasher}, ops::Range};

use proc_macro2::{TokenStream, Span};
use quote::{ToTokens, TokenStreamExt, format_ident};
use rangemap::RangeMap;
use syn::{parse_macro_input, Item, Expr, punctuated::Punctuated, token::{Comma}, Block, Stmt, Ident, parenthesized, visit::Visit, visit_mut::VisitMut, spanned::Spanned, PatIdent, ItemFn, parse_quote, BinOp, ExprCall, Signature, ExprMacro, parse2, ExprLet, Local,};

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct LineColumn {
    line: usize,
    column: usize,
}

impl From<proc_macro::LineColumn> for LineColumn {
    fn from(lc: proc_macro::LineColumn) -> Self {
        Self {
            line: lc.line,
            column: lc.column,
        }
    }
}

impl From<proc_macro2::LineColumn> for LineColumn {
    fn from(lc: proc_macro2::LineColumn) -> Self {
        Self {
            line: lc.line,
            column: lc.column,
        }
    }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct Bytespan {
    source_hash: u64,
    start: LineColumn,
    end: LineColumn,
}

impl Bytespan {
    fn new(source_hash: u64, span: Span) -> Self {
        Self {
            source_hash,
            start: span.start().into(),
            end: span.end().into(),
        }
    }
}

struct Place {}

impl Display for Place {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Place")
    }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct Source {
    ident: String,
    bytespan: Bytespan,
}

impl Display for Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Source{{{}}}", self.ident)
    }
}

impl Source {
    fn new_from_ident(source_hash: u64, ident: &Ident) -> Self {
        Self {
            ident: ident.span().unwrap().source_text().unwrap(),
            bytespan: Bytespan::new(source_hash, ident.span().into()),
        }
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
struct Sources(HashSet<Source>);

impl Sources {
    fn new() -> Self {
        Self(HashSet::new())
    }

    fn insert(&mut self, source: Source) {
        self.0.insert(source);
    }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct Use {
    ident: String
}

impl From<&Ident> for Use {
    fn from(ident: &Ident) -> Self {
        Self{ident: ident.to_string()}
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
struct Uses{
    source_hash: u64,
    uses: RangeMap<proc_macro::LineColumn, Use>,
}

impl Uses {
    fn new(source_hash: u64) -> Self {
        Self {
            source_hash,
            uses: RangeMap::new(),
        }
    }
}

impl<'ast> Visit<'ast> for Uses {
    fn visit_expr_macro(&mut self, node: &ExprMacro) {
        let syn::ExprMacro{mac, ..} = node;
        let syn::Macro{path, tokens, ..} = mac;
        if path.get_ident().is_some() {
            let format_args: FormatArgs = parse2(tokens.clone()).unwrap();
            for arg in format_args.0.iter().skip(1) {
                self.visit_expr(arg);
            }
        }
    }

    fn visit_ident(&mut self, ident: &'ast Ident) {
        let ident_start = ident.span().unwrap().start();
        let ident_end = ident.span().unwrap().end();
        let ident_range = ident_start..ident_end;
        self.uses.insert(ident_range, Use::from(ident));
    }
}

#[derive(Clone, Debug)]
struct Scopes {
    #[allow(dead_code)]
    source_hash: u64,
    scopestack: Vec<(ScopeKind, proc_macro::LineColumn, proc_macro::LineColumn, Sources)>,
    scopes: RangeMap<proc_macro::LineColumn, (ScopeKind, Sources)>,
}


#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum ScopeKind {
    Fn,
    Block,
    Local,
}

impl Scopes {
    fn new(source_hash: u64) -> Self {
        Self{
            source_hash,
            scopestack: vec![],
            scopes: RangeMap::new(),
        }
    }

    fn push_scope(&mut self, kind: ScopeKind, start: proc_macro::LineColumn, end: proc_macro::LineColumn) {
        self.scopestack.push((kind, start, end, Sources::new()));
    }

    fn pop_scope(&mut self, _end: proc_macro::LineColumn) {
        if let Some((kind, start, end, scope)) = self.scopestack.pop() {
            self.scopes.insert(start..end, (kind, scope));
        }
    }
}

impl<'ast> Visit<'ast> for Scopes {
    fn visit_item_fn(&mut self, item_fn: &'ast ItemFn) {
        let span = item_fn.span().unwrap();
        self.push_scope(ScopeKind::Fn, span.start(), span.end());
        syn::visit::visit_item_fn(self, item_fn);
        self.pop_scope(span.end());
    }

    fn visit_block(&mut self, block: &'ast Block) {
        let span = block.span().unwrap();
        self.push_scope(ScopeKind::Block, span.start(), span.end());
        syn::visit::visit_block(self, block);
        self.pop_scope(span.end());
    }

    fn visit_local(&mut self, node: &'ast Local) {
        let span = node.span().unwrap();
        let prev_end = self.scopestack.last().unwrap().2;
        self.push_scope(ScopeKind::Local, span.start(), prev_end);
        syn::visit::visit_local(self, node);
        self.pop_scope(prev_end);
    }

    fn visit_expr_let(&mut self, node: &'ast ExprLet) {
        let span = node.span().unwrap();
        let prev_end = self.scopestack.last().unwrap().2;
        self.push_scope(ScopeKind::Local, span.start(), prev_end);
        syn::visit::visit_expr_let(self, node);
        self.pop_scope(prev_end);
    }

    fn visit_pat_ident(&mut self, ident: &'ast PatIdent) {
        self.scopestack
            .last_mut()
            .map(|ref mut scope| {
                scope.3.insert(Source::new_from_ident(self.source_hash, &ident.ident))
            });
    }
}

struct Parts<'ast> {
    source_hash: u64,
    scopes: &'ast Scopes,
    uses: &'ast Uses,
}

type UseRange = Range<proc_macro::LineColumn>;
type SourceRange = Range<proc_macro::LineColumn>;
type Binding = (UseRange, Use, SourceRange, ScopeKind, Source);

impl<'ast> Parts<'ast> {
    fn new(source_hash: u64, scopes: &'ast Scopes, uses: &'ast Uses) -> Self {
        Self{
            source_hash,
            scopes,
            uses,
        }
    }

    fn bindings(&self, expr: &Expr) -> Vec<Binding> {
        let expr_start = expr.span().unwrap().start();
        let expr_end = expr.span().unwrap().end();
        let expr_range = expr_start..expr_end;
        let scopes = self.scopes.scopes.overlapping(&expr_range);
        let scopes = scopes.collect::<Vec<_>>();
        let uses = self.uses.uses.overlapping(&expr_range);
        let uses = uses.collect::<Vec<_>>();
        let mut bindings: Vec<(_, Use, _, ScopeKind, Source)> = vec![];

        for (var_range, var) in uses.iter().cloned() {
            for (scope_range, (scope_kind, sources)) in scopes.iter().cloned().rev() {
                if scope_range.contains(&var_range.start) && scope_range.contains(&var_range.end) {
                    sources.0.iter().find(|source| source.ident == var.ident).map(|source| {
                        bindings.push((var_range.clone(), var.clone(), scope_range.clone(), *scope_kind, source.clone()));
                    });
                    break;
                }
            }
        }

        bindings
    }

    fn visit_expr_call_arg_mut(&mut self, expr: &mut Expr) {
        let expr_clone = expr.clone();
        self.visit_expr_mut(expr);
        if let Some(ident) = as_ident(&expr_clone) {
            let mut bindings = self.bindings(expr);
            let (_var_range, _var, _scope_range, scope_kind, source) = bindings
                .pop()
                .unwrap_or_else(|| panic!("missing bindings for expr: {expr:?}"));
            if scope_kind == ScopeKind::Local {
                let frame_ident = format_ident!("__wye_frame_{}", ident);
                let var_place = hash(source.bytespan);
                *expr = parse_quote!(({
                    let __wye_ret = #expr;
                    __wye.push_var((#frame_ident, #var_place));
                    __wye.set_last_node((#frame_ident, #var_place));
                    __wye_ret
                }));
            } else {
                *expr = parse_quote!(({
                    let __wye_ret = #expr;
                    __wye.push_var(__wye.last_node());
                    __wye_ret
                }));
            }
        } else {
            *expr = parse_quote!(({
                let __wye_ret = #expr;
                __wye.push_var(__wye.last_node());
                __wye_ret
            }));
        }
    }

    fn visit_fn_block_mut(&mut self, sig: &Signature, node: &mut Block) {
        self.visit_block_mut(node);
        for (input_slot, input) in sig.inputs.iter().enumerate().rev() {
            if let syn::FnArg::Typed(syn::PatType{pat, ..}) = input {
                if let syn::Pat::Ident(syn::PatIdent{ident, ..}) = pat.as_ref() {
                    let ident_str = ident.to_string();
                    let bytespan = Bytespan::new(self.source_hash, ident.span().unwrap().into());
                    let slot = hash(&bytespan);
                    node.stmts.insert(0, parse_quote!(
                        if let Some((__wye_arg_frame, __wye_arg_slot)) = __wye_frame_args.get(#input_slot).copied().flatten() {
                            if __wye_arg_frame != __wye_frame || __wye_arg_slot != #slot {
                                __wye.edge(__wye_arg_frame, __wye_arg_slot, __wye_frame, #slot);
                            }
                        }
                    ));
                    node.stmts.insert(0, parse_quote!(
                        __wye.node(__wye_frame, #slot, Some(#ident_str.into()), format!("{:?}", &#ident));
                    ));
                }
            }
        }
        node.stmts.insert(0, parse_quote!(let (__wye_frame, __wye_frame_args) = __wye.frame();));
        node.stmts.insert(0, parse_quote!(let __wye = get_wye();));
    }

    fn compile(&mut self, stmt_hack: Option<u64>, expr: &mut Expr) {
        let expr_clone = expr.clone();
        let expr_source = expr.span().unwrap().source_text();
        let bindings = self.bindings(expr);

        let place = stmt_hack.unwrap_or_else(|| {
            hash(Bytespan::new(self.source_hash, expr.span().unwrap().into()))
        });

        syn::visit_mut::visit_expr_mut(self, expr);

        let mvar: Expr = if let Some(ident) = as_ident(expr) {
            let ident = ident.to_string();
            parse_quote!(Some(#ident.into()))
        } else if let Some(binop) = as_binop(expr) {
            let binop = binop.to_token_stream().to_string();
            parse_quote!(Some(#binop.into()))
        } else if stmt_hack.is_some() {
            if let Expr::Let(ExprLet{pat: syn::Pat::Ident(ident), ..}) = &expr {
                let ident = ident.ident.to_string();
                parse_quote!(Some(#ident.into()))
            } else {
                parse_quote!(None::<String>)
            }
        } else {
            parse_quote!(None::<String>)
        };

        let edges: Vec<Stmt> = if as_ident(expr).is_some() {
            vec![]
        } else {
            bindings.iter().filter_map(|(_var_range, var, _scope_range, scope_kind, source)| {
                if scope_kind == &ScopeKind::Fn {
                    let bytespan = &source.bytespan;
                    let var_place = hash(&bytespan);
                    return Some(parse_quote!(
                        __wye.edge(__wye_frame, #var_place, __wye_frame, #place);
                    ))
                } else if scope_kind == &ScopeKind::Local {
                    let bytespan = &source.bytespan;
                    let var_place = hash(&bytespan);
                    let parent_frame = format_ident!("__wye_frame_{}", var.ident);
                    if stmt_hack.is_none() {
                        return Some(parse_quote!(
                            __wye.edge(#parent_frame, #var_place, __wye_outer_frame, #place);
                        ));
                    } else {
                        return Some(parse_quote!(
                            __wye.edge(__wye_expr_frame, __wye_expr_place, __wye_frame, #var_place);
                        ))
                    }
                }
                None
            }).collect::<Vec<_>>()
        };

        match expr_clone {
            Expr::Call(_) => {
                *expr = parse_quote!(({
                    let _ = "case: Expr::Call";
                    let _ = #expr_source;
                    let __wye = get_wye();
                    let (__wye_outer_frame, _) = __wye.frame();
                    __wye.declare_node(__wye_outer_frame, #place);
                    __wye.push_frame();
                    let __wye_ret = #expr;
                    __wye.pop_frame();
                    let (__wye_inner_frame, __wye_inner_slot) = __wye.last_node();
                    __wye.define_node(__wye_outer_frame, #place, Some(#expr_source.into()), format!("{:?}", &__wye_ret));
                    __wye.edge(__wye_inner_frame, __wye_inner_slot, __wye_outer_frame, #place);
                    #(#edges)*;
                    __wye_ret
                }));
            },
            Expr::Macro(_) => {
                *expr = parse_quote!(({
                    let _ = "case: Expr::Macro";
                    let _ = #expr_source;
                    let __wye = get_wye();
                    let (__wye_outer_frame, _) = __wye.frame();
                    __wye.declare_node(__wye_outer_frame, #place);
                    let __wye_ret = #expr;
                    __wye.define_node(__wye_outer_frame, #place, Some(#expr_source.into()), format!("{:?}", &__wye_ret));
                    #(#edges)*;
                    __wye_ret
                }));
            },
            Expr::Let(syn::ExprLet{pat: syn::Pat::Ident(_ident), expr: inner_expr, ..}) if stmt_hack.is_none() => {
                *expr = parse_quote!(
                    (get_wye().frame().0, {
                        let _ = "case: Expr::Let";
                        let _ = #expr_source;
                        let __wye = get_wye();
                        let (__wye_outer_frame, _) = __wye.frame();
                        __wye.declare_node(__wye_outer_frame, #place);
                        __wye.push_frame();
                        let __wye_ret = #inner_expr;
                        __wye.pop_frame();
                        __wye.define_node(__wye_outer_frame, #place, #mvar, format!("{:?}", &__wye_ret));
                        #(#edges)*;
                        __wye_ret
                    })
                );
            },
            Expr::Let(syn::ExprLet{pat: syn::Pat::Ident(_ident), expr: mut inner_expr, ..}) => {
                syn::visit_mut::visit_expr_mut(self, inner_expr.as_mut());
                // only emit edges if inner_expr will have defined a last_node:
                if matches!(&*inner_expr, Expr::Lit(_)) {
                    *expr = parse_quote!(
                        (get_wye().frame().0, {
                            let _ = "case: stmt_hack.lit";
                            let _ = #expr_source;
                            let __wye = get_wye();
                            let (__wye_frame, _) = __wye.frame();
                            __wye.declare_node(__wye_frame, #place);
                            let __wye_ret = #inner_expr;
                            __wye.define_node(__wye_frame, #place, #mvar, format!("{:?}", &__wye_ret));
                            __wye.push_frame(); __wye.pop_frame();
                            __wye_ret
                        })
                    );
                } else {
                    *expr = parse_quote!(
                        (get_wye().frame().0, {
                            let _ = "case: stmt_hack";
                            let _ = #expr_source;
                            let __wye = get_wye();
                            let (__wye_frame, _) = __wye.frame();
                            __wye.declare_node(__wye_frame, #place);
                            let __wye_ret = #inner_expr;
                            let (__wye_expr_frame, __wye_expr_place) = __wye.last_node();
                            __wye.define_node(__wye_frame, #place, #mvar, format!("{:?}", &__wye_ret));
                            #(#edges)*;
                            __wye.push_frame(); __wye.pop_frame();
                            __wye_ret
                        })
                    );
                }
            },
            _ if as_ident(&expr_clone).is_none() => {
                *expr = parse_quote!(({
                    let _ = "case: non-ident";
                    let _ = #expr_source;
                    let __wye = get_wye();
                    let (__wye_frame, _) = __wye.frame();
                    __wye.declare_node(__wye_frame, #place);
                    let __wye_ret = #expr;
                    __wye.define_node(__wye_frame, #place, #mvar, format!("{:?}", &__wye_ret));
                    #(#edges)*;
                    __wye_ret
                }));
            },
            _ => {},
        }
    }
}

impl<'ast> VisitMut for Parts<'ast> {

    fn visit_item_fn_mut(&mut self, node: &mut ItemFn) {
        // See syn::visit_mut::visit_item_fn_mut(self, node);
        let sig_clone = node.sig.clone();
        for it in &mut node.attrs {
            self.visit_attribute_mut(it);
        }
        self.visit_visibility_mut(&mut node.vis);
        self.visit_signature_mut(&mut node.sig);
        self.visit_fn_block_mut(&sig_clone, &mut *node.block);
    }

    fn visit_expr_macro_mut(&mut self, node: &mut ExprMacro) {
        let syn::ExprMacro{mac, ..} = node;
        let syn::Macro{path, tokens, ..} = mac;
        if path.get_ident().is_some() {
            let mut format_args: FormatArgs = parse2(tokens.clone()).unwrap();
            for arg in format_args.0.iter_mut().skip(1) {
                self.visit_expr_mut(arg);
            }
            *tokens = format_args.to_token_stream();
        }
    }

    fn visit_expr_call_mut(&mut self, node: &mut ExprCall) {
        // See syn::visit_mut::visit_expr_call_mut(self, expr_call);
        // however, when visiting children, don't visit the actual callable
        // being called
        for it in &mut node.attrs {
            self.visit_attribute_mut(it);
        }
        for el in Punctuated::pairs_mut(&mut node.args) {
            let (it, _p) = el.into_tuple();
            self.visit_expr_call_arg_mut(it);
        }
    }

    fn visit_stmt_mut(&mut self, stmt: &mut Stmt) {
        match stmt {
            Stmt::Local(local) => {
                if let Local{attrs, let_token, pat: pat@syn::Pat::Ident(ident), init: Some((eq_token, expr)), semi_token} = &local {
                    let expr = Box::new(*expr.clone());
                    let mut fake_expr = Expr::Let(ExprLet{
                        attrs: attrs.clone(),
                        let_token: let_token.clone(),
                        pat: pat.clone(),
                        eq_token: eq_token.clone(),
                        expr,
                    });
                    let ident_frame_var = format_ident!("__wye_frame_{}", ident.ident);
                    self.compile(Some(hash(Bytespan::new(self.source_hash, ident.ident.span()))), &mut fake_expr);
                    let mut pat_elems: Punctuated<syn::Pat, Comma> = Default::default();
                    let pat_arg_frame = syn::Pat::Ident(syn::PatIdent{
                        attrs: vec![],
                        by_ref: None,
                        mutability: None,
                        ident: ident_frame_var,
                        subpat: None,
                    });
                    pat_elems.push_value(pat_arg_frame);
                    pat_elems.push_punct(syn::token::Comma::default());
                    pat_elems.push_value(pat.clone());
                    *stmt = Stmt::Local(Local{
                        attrs: attrs.clone(),
                        let_token: let_token.clone(),
                        pat: syn::Pat::Tuple(syn::PatTuple{
                            attrs: vec![],
                            paren_token: syn::token::Paren::default(),
                            elems: pat_elems,
                        }),
                        init: Some((eq_token.clone(), Box::new(fake_expr))),
                        semi_token: semi_token.clone(),
                    });
                } else {
                    syn::visit_mut::visit_stmt_mut(self, stmt);
                }
            },
            _ => {
                syn::visit_mut::visit_stmt_mut(self, stmt);
            }
        }
    }

    fn visit_expr_mut(&mut self, expr: &mut Expr) {
        self.compile(None, expr);
    }
}

fn as_ident(expr: &Expr) -> Option<&Ident> {
    if let Expr::Path(expr_path) = expr {
        return expr_path.path.get_ident()
    }
    None
}

fn as_binop(expr: &Expr) -> Option<&BinOp> {
    if let Expr::Binary(expr_binary) = expr {
        return Some(&expr_binary.op)
    }
    None
}

fn hash<T: Hash>(t: T) -> u64 {
    let mut h = DefaultHasher::new();
    t.hash(&mut h);
    h.finish()
}

#[derive(Debug)]
struct FormatArgs(Punctuated<Expr, Comma>);

impl syn::parse::Parse for FormatArgs {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut format_args: Punctuated<Expr, Comma> = Punctuated::new();
        loop {
            format_args.push_value(input.parse()?);
            if input.is_empty() {
                break;
            }
            format_args.push_punct(input.parse()?);
        }
        Ok(FormatArgs(format_args))
    }
}

impl quote::ToTokens for FormatArgs {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        tokens.append_separated(&self.0, Comma::default());
    }
}

struct Stmts(Vec<Stmt>);

impl syn::parse::Parse for Stmts {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        Block::parse_within(input).map(Stmts)
    }
}

impl quote::ToTokens for Stmts {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let brace_token = syn::token::Brace::default();
        brace_token.surround(tokens, |tokens| {
            tokens.append_all(&self.0);
        });
    }
}

struct WyeArg{
    ident: syn::Ident,
    colon_token: syn::Token![:],
    expr: syn::Expr,
}

impl syn::parse::Parse for WyeArg {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        Ok(Self{
            ident: input.parse()?,
            colon_token: input.parse()?,
            expr: input.parse()?,
        })
    }
}

impl quote::ToTokens for WyeArg {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        self.ident.to_tokens(tokens);
        self.colon_token.to_tokens(tokens);
        self.expr.to_tokens(tokens);
    }
}

struct WyeArgs(Punctuated<WyeArg, Comma>);

impl syn::parse::Parse for WyeArgs {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut args = Punctuated::new();
        loop {
            if input.is_empty() {
                break;
            }
            args.push(input.parse()?);
            if input.is_empty() {
                break;
            }
            let comma: Comma = input.parse()?;
            args.push_punct(comma);
        }
        Ok(Self(args))
    }
}

impl quote::ToTokens for WyeArgs {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        tokens.append_separated(self.0.iter(), Comma::default())
    }
}

type WyeArgMap = HashMap<Ident, Expr>;

impl WyeArgs {
    fn process(&self) -> WyeArgMap {
        let mut args = HashMap::new();
        for arg in self.0.iter() {
            args.insert(arg.ident.clone(), arg.expr.clone());
        }
        args
    }
}

struct WyreExpr {
    args: Option<(syn::token::Paren, WyeArgs)>,
    stmts: Stmts,
}

impl syn::parse::Parse for WyreExpr {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        if input.peek(syn::token::Paren) {
            let content;
            Ok(Self {
                args: Some((parenthesized!(content in input), content.parse()?)),
                stmts: input.parse()?,
            })
        } else {
            Ok(Self {
                args: None,
                stmts: input.parse()?
            })
        }
    }
}

impl quote::ToTokens for WyreExpr {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        // Note: self.args intentionally does *not* get re-printed
        // since it would not be valid syntax.
        // if let Some((paren_token, args)) = self.args {
        //     paren_token.surround(tokens, |tokens| {
        //         args.to_tokens(tokens);
        //     })
        // }
        self.stmts.to_tokens(tokens);
    }
}

#[proc_macro_attribute]
pub fn wye(args: proc_macro::TokenStream, input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let args = if !args.is_empty() {
        parse_macro_input!(args as WyeArgs).process()
    } else {
        WyeArgMap::new()
    };
    let _ = args;

    let mut input = parse_macro_input!(input as Item);

    let source_hash = hash(proc_macro::Span::call_site().source_text().unwrap());

    let mut scopes = Scopes::new(source_hash);
    scopes.visit_item(&input);

    let mut uses = Uses::new(source_hash);
    uses.visit_item(&input);

    let mut parts = Parts::new(source_hash, &scopes, &uses);
    parts.visit_item_mut(&mut input);

    let tokens = input.into_token_stream();
    tokens.into()
}

#[proc_macro]
pub fn wyre(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let mut input = parse_macro_input!(input as WyreExpr);

    let args = input.args.as_ref().map(|args| args.1.process()).unwrap_or_else(WyeArgMap::new);
    let _ = args;

    let source_hash = hash(proc_macro::Span::call_site().source_text().unwrap());
    let span = input.span().unwrap();

    let mut scopes = Scopes::new(source_hash);
    scopes.push_scope(ScopeKind::Block, span.start(), span.end());
    for stmt in &input.stmts.0 {
        scopes.visit_stmt(stmt)
    }

    let mut uses = Uses::new(source_hash);
    for stmt in &input.stmts.0 {
        uses.visit_stmt(stmt)
    }

    let mut parts = Parts::new(source_hash, &scopes, &uses);
    for stmt in &mut input.stmts.0 {
        parts.visit_stmt_mut(stmt);
    }

    input.stmts.0.insert(0, parse_quote!(__wye.push_frame();));
    input.stmts.0.insert(0, parse_quote!(let __wye = get_wye();));

    let tokens = input.into_token_stream();
    tokens.into()
}